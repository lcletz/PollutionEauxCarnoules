---
title: "GAMMs Whole Imputation Algorithm"
author: "CLETZ Laura"
date: "18/06/2025"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Packages needed:
```{r}
library(data.table)
library(dplyr)
library(tidyverse)
library(mgcv)
library(tibble)
library(tidyselect)
library(gam)
here::i_am("R/GAMMS_imputation_algo.Rmd")
library(here)
```

```{r, warning=FALSE}
data <- read.table(here('processed','Source_S1_v2.csv'), dec = c(',','.') , sep = ";", header = TRUE) %>% 
  mutate_at(2:45, function(x) as.numeric(as.character(gsub(',','.', x))))
data$Dates <- as.Date(data$Dates, format="%Y-%m-%d")
```

```{r}
gen <- read.table(here('processed','Generargues_complete.csv'), dec = ',', sep = ";", header = TRUE) 
gen$Dates <- as.Date(gen$Dates, format="%Y-%m-%d")
gen$monthly_rainfall <- as.numeric(gen$monthly_rainfall)

data <- gen %>%
  inner_join(data, by="Dates")
```

```{r}
dis <- read.table(here('processed','S1_discharge.csv'), dec = c(',','.'), sep = ";", header = TRUE)
dis$Dates <- as.Date(dis$Dates, format="%Y-%m-%d")
dis$monthly_discharge <- as.numeric(dis$monthly_discharge)

dis2 <- read.table(here('processed','discharge_ESU.csv'), dec = c(',','.'), sep = ";", header = TRUE)
dis2$Dates <- as.Date(dis2$Dates, format="%Y-%m-%d")

dis3 <- dis %>%
  bind_rows(dis2)

data <- data %>%
  left_join(dis3) %>% 
  distinct(Dates, .keep_all = TRUE)

rm(dis) ; rm(dis2) ; rm(dis3) ; rm(gen)
```

```{r}
safe_data <- data[(1:49),]
safe_data <- safe_data[which(colSums(is.na(safe_data))*100/nrow(safe_data)<=15)]
```

```{r}
add_lag <- function(df, nb_lag){
  
  init_df <- df
  
  for(i in 1:nb_lag){
    
    for(col in 2:ncol(init_df)){
      
      new_col <- df[[col]]
      new_col <- new_col[ 1:(length(new_col)-i) ]
      new_col <- c( rep(as.numeric(NA), i), new_col)
      
      name_col <- paste0( names(df[col]), "_lag_", i )
      df <- df %>%
        bind_cols( new_col )
      colnames( df )[ncol(df)] <- name_col
    }
  }
  
  return(df)
}

safe_data <- add_lag(safe_data, 1)
```

```{r}
step_GAMMs <- function(df){
  
  list_final <- list()
  control <- lmeControl(msMaxIter = 200, msMaxEval = 200, tolerance = 1e-4,
                        niterEM = 50, opt = "optim")
  
  lag_index <- grep("lag", names(df))
  
  
  for(resp in 2:ncol( df[-lag_index] )){
    cat('\nVariable:', names(df[resp]), '\n')
    
    best_bic <- Inf
    
    lag_resp <- grep( names(df[resp]), names(df) )
    
    
    formula <- paste0( names(df[resp]), '~')
    # Formula including every available variable:
    for(name in 2:ncol(df)){
      if( !(name %in% lag_resp) ){
        formula <- paste0( formula, "s(", names( df[name] ), ", k=4, bs='re') +" )
      }
    }
    formula <- formula(gsub('.{1}$', '', formula))
    cat('\nFormula:', as.character(formula), '\n')
      
    
    # Initialization of best model with all predictors
    best_model <- try(gamm(formula, data = df, 
                    correlation = corARMA(form = ~1, p=1, q=1), 
                    family = gaussian(), control = control, na.action = na.omit),
                    silent = TRUE)
    if (inherits(best_model, "try-error")) {
        best_model <- try(gamm(formula, data = df, 
                        correlation = corARMA(form = ~1, p=1), 
                        family = gaussian(), control = control, na.action = na.omit),
                        silent = TRUE)
      if (inherits(best_model, "try-error")) {
          best_model <- try(gamm(formula, data = df, 
                            correlation = corARMA(form = ~1, p=1, q=1), 
                            family = gaussian(), control = control, na.action = na.omit),
                            silent = TRUE)
       }
     }
    
    current_bic <- BIC(best_model$lme)
    
    worst_pred <- list()
    
    
    
    while(current_bic <= best_bic){
      
      fit <- summary(best_model$gam)
      fit <- rownames_to_column( data.frame(fit$s.table) )
      fit[1] <- lapply(fit[1], function(x) gsub("^.{2}|.{1}$", "", x))
      
      minus_pred <- fit$rowname[ which(fit$p.value == max(fit$p.value)) ]    # New worst predictor
      worst_pred <- append(worst_pred, minus_pred)      # List of worst predictors
            
      # Formula including every available variable but the worst predictors:
      formula <- paste0( names(df[resp]), '~')
      for(name in 2:ncol(df)){
        if( name != resp & !(names(df[name]) %in% worst_pred) ){
           formula <- paste0( formula, "s(", names( df[name] ), ", k=4, bs='re') +" )
        }
      }
      formula <- formula(gsub('.{1}$', '', formula))
      cat('\nNew formula:', as.character(formula), '\n')
       
      if ( length(worst_pred) > length(df)-5 ) { # length(df) - Dates - Response - 3 predictors
        cat('\nThis formula is too small! \n')
        break
      } 
      
      model <- try(gamm(formula, data = df, 
                   correlation = corARMA(form = ~1, p=1, q=1), 
                   family = gaussian(), control = control, na.action = na.omit),
                   silent = TRUE)
     if (inherits(model, "try-error")) {
        model <- try(gamm(formula, data = df, 
                     correlation = corARMA(form = ~1, p=1), 
                     family = gaussian(), control = control, na.action = na.omit),
                     silent = TRUE)
       if (inherits(model, "try-error")) {
          model <- try(gamm(formula, data = df, 
                       correlation = corARMA(form = ~1, p=1, q=1), 
                       family = gaussian(), control = control, na.action = na.omit),
                       silent = TRUE)
        }
     }
      
      current_bic <- BIC(model$lme)
  
      if (current_bic < best_bic) {
          best_bic <- current_bic
          best_model <- model
          current_bic <- current_bic - 1
          cat('\nA better model has been chosen! \n')
      }
      
    }
    list_model <- list(names(df[resp]), best_model)
    list_final <- c(list_final, list(list_model))
  }
  return(list_final)
}
```

```{r}
#mini_test <- safe_data[c(1:9,32)]
#l <- step_GAMMs(mini_test)
new_safe_data <- safe_data[c(1:9, 12, 15:26, 28, 30, 33, 38, 39)]
gam_res <- step_GAMMs(new_safe_data)
#gam_res <- step_GAMMs(safe_data)
```

```{r}
impute_GAMMs <- function(df, model){
  
  list_final <- list()
  lag_index <- grep("lag", names(df))
  
  # Check if there is any columns without NAs where we need to impute values
  for(resp in 2:ncol( df[-lag_index] )){ # 2 since the first column is supposed to be Dates
    list_na <- list()
    list_resp <- list()
    
    index_with_na <- which(is.na(df[resp]))
    
    if(length(index_with_na) == 0) {
      next
    } 
    
    else {
      cat("\nImputation of variable", names(df[resp]))
      
      newdf <- df[index_with_na,]
      
      for (col in names(newdf)) {
        if( any( is.na( newdf[[col]] ) ) ){
          newdf[ is.na( newdf[[col]] ), col ] <- mean( df[[col]], na.rm = TRUE)
        }  
      }
        
      list_na <- append( list_na, list(index_with_na) )
      list_resp <- append( list_resp, names(df[resp]) )
      list_final <- append( list_final, list(list_resp, list_na) )
      
      index <- 1
      while( names(df[resp]) != model[[index]][[1]] ){
        index <- index + 1
      }
      
      formula <- model[[index]][[2]]$gam$formula
      cat(' using formula:', as.character(formula), '\n')
      
      gamm <- model[[index]][[2]]$gam
    
    # Predict the NAs
      df[[resp]][index_with_na] <- predict.gam(gamm, newdf, na.action = na.exclude)
    }
  }
  return( list(df, list_final) )
}
```

```{r}
#ll <- impute_GAMMs(mini_test, l)
first_impute <- impute_GAMMs(new_safe_data, gam_res)
```


```{r}
impute_iter <- function(imputed, model, max_iter = 10, tol = 1e-4) {

  df <- imputed[[1]]
  df_old <- df
  lag_index <- grep("lag", names(df))

  
  for (iter in 1:max_iter) {
    cat("\nIteration", iter, "\n")

    for (resp in 3:ncol(df[-lag_index])) {

      
      names_index <- 1
      while (names(df[resp]) != imputed[[2]][[names_index]]) {
        names_index <- names_index + 1
      }
      
      index_with_na <- unlist(imputed[[2]][[names_index + 1]])

      #cat("Imputing variable:", names(df[resp]), "at indices:", index_with_na, "\n")
      newdf <- df[index_with_na, ]
      
      for (col in names(newdf)) {
        if( any( is.na( newdf[[col]] ) ) ){
          newdf[ is.na( newdf[[col]] ), col ] <- mean( df[[col]], na.rm = TRUE)
        }  
      }
      
      
      gam_index <- 1
      while (names(df[resp]) != model[[gam_index]][[1]]) {
        gam_index <- gam_index + 1
      }
      gamm <- model[[gam_index]][[2]]$gam

      df[[resp]][index_with_na] <- predict.gam(gamm, newdf, na.action = na.exclude)
    }
    
    threshold <- sum(( df_old[-c(1,lag_index)] - df[-c(1,lag_index)] )^2, na.rm = TRUE)
    cat("\nPrecision reached:", threshold, "but tolerance's threshold is:", tol, "\n")
    
    if ( threshold < tol) {
      cat("\nConverged at iteration", iter, "\n")
      break
    }
    
    df_old <- df
  }

  return(df)
}

```

```{r}
#oh <- impute_iter(ll, l, max_iter = 20)
data_complete <- impute_iter(first_impute, gam_res, max_iter = 200)
```

```{r}
write_delim(data_complete, here("processed", "S1_gamm_2004_2008.csv"), delim=";")
```

```{r}
impute_byrow <- function(na_df, df, model){
  
  index <- nrow(df)
  list_final <- list()
  
  while( index < nrow(na_df) ){
    
    cat("\n Il reste", nrow(na_df)-nrow(df), "ligne(s) à compléter")
    
    last_date <- df[[1]][nrow(df)]
    corres_index <- which(na_df[[1]] == as.Date(last_date))
    
    if(index + 2 > nrow(na_df)){
      
      cat("\n Traitement de la ligne après la date", as.character(last_date))
    
      next_rows <- na_df[ corres_index + 1, ]
    
      df <- df %>% bind_rows(next_rows)
      l <- impute_GAMMs(df, model)
      
      df <- l[[1]]
      list_ind <- l[[2]]
      list_final <- append(list_final, list_ind)
    
      cat("\n Imputation de la nouvelle ligne réussie")
    
      index <- index + 1
      
    } else { 
      cat("\n Traitement des deux lignes après la date", as.character(last_date))
    
      next_rows <- na_df[ c(corres_index + 1, corres_index + 2), ]
    
      df <- df %>% bind_rows(next_rows)
      l <- impute_GAMMs(df, model)
      
      df <- l[[1]]
      list_ind <- l[[2]]
      list_final <- append(list_final, list_ind)
    
      cat("\n Imputation des nouvelles lignes réussie")
      
      index <- index + 2 }
  }
  
  return(list(df, list_final))
}
```

```{r}
data <- add_lag(data, 1)
data <- data %>% select( names(data_complete) )
```

```{r}
#test <- data[1:54,]
#test_co <- impute_byrow(test, data_complete, gam_res)
data_complete_long <- impute_byrow(data, data_complete, gam_res)
```

```{r}
list_var <- list()
list_na <- list()
list_final <- list()

n <- length(data_complete_long[[2]])

for (col in 3:ncol(data)) {
  var <- list()

  for (i in 1:n) {
    if (names(data[col]) == data_complete_long[[2]][[i]]) {
      var <- c(var, data_complete_long[[2]][[i + 1]])
    }
  }

  var <- unlist(var)
  list_na <- append(list_na, list(var))
  list_var <- append(list_var, list(names(data[col])))
  list_final <- append(list_final, list(list_var, list_na))
}

list_final <- c( list_final[[49]][1:16], list_final[[50]][1:16] )
```

```{r}
new_order <- as.vector(rbind(1:16, 17:32))
reordered_list <- list_final[new_order]

new_impute <- list(data_complete_long[[1]], reordered_list)

new_impute[[2]] <- lapply( seq_along(new_impute[[2]]), function(i) list( new_impute[[2]][[i]] ) )
```

```{r}
attempt <- impute_iter(new_impute, gam_res, max_iter = 1000)
```

```{r}
write_delim(attempt, here('processed', 'S1_gamm_2004_2018.csv'), delim=";")
```




